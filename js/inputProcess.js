//This is the main JS script to handle calls to both the Google Maps APIs (Google Maps JavaScript API and Timezone
//API) and the Tomorrow.IO API.

//In order to use the require function on the browser side, the browserify package is used to create the bundle.js
//file, which contains the source code seen below as well as code generated by using the browserify package.
//Because of this, bundle.js is loaded into index.html, instead of this file.

"use strict";

//moment.js is used to send compatible date and time information to the Tomorrow.IO API.
const moment = require('moment');
//node-fetch is used to comunicate with the APIs, as well as retrieving the keys from key.json.
const fetch = require('node-fetch');
//query-string is used to organize the information needed to send to Tomorrow.IO API, including the key, location
//information, and others that can be found below.
const queryString = require('query-string'); 

// This is the URL to access the Tomorrow.IO API.
const getTimelineURL = "https://api.tomorrow.io/v4/timelines";

//Use node-fetch to gather the key for the Tomorrow.IO API. This .json file should be created locally,
//based on the key.json.dist file.
var keys;
var apikey;

fetch("../key.json")
.then(response => response.json())
.then(json => keys = json)
.then(keys => apikey = keys.tomorrowKey)

// These are the fields retrieved from the Tomorrow.IO API and that will be displayed to the user.
const fields = [
    "precipitationProbability",
    "precipitationIntensity",
    "precipitationType",
    "windSpeed",
    "windGust",
    "windDirection",
    "temperature",
    "temperatureApparent",
    "cloudCover",
    "cloudBase",
    "cloudCeiling",
    "weatherCode",
  ];

//This specifies the unit system used for this website.
const units = "imperial";

//These are the default timesteps for the weather.
const timesteps = ["1m", "1h", "1d"];

//This function takes in the weatherData gathered from Tomorrow.IO and pastes the information
//on the forms found on the webpage.
function displayWeatherData(weatherData, givenTimezone)
{
    //Once the data is ready to be displayed, unhide the scroller and the switch.
    console.log(weatherData);
    document.getElementById("scrollid").hidden = false;
    document.getElementById("dataSwitch").hidden = false;

    //Gather the labels for the current time data.
    let i = 1
    let labid = "label"+i.toString();
    let ppid = "PP"+i.toString();
    let piid = "PI"+i.toString();
    let ptid = "PT"+i.toString();
    let wsid = "WS"+i.toString();
    let wgid = "WG"+i.toString();
    let wdid = "WD"+i.toString();
    let tid = "T"+i.toString();
    let taid = "TA"+i.toString();


    //Translate the current time into the correct timezone for the given city.
    let localDate = new Date(weatherData.data.timelines[0].intervals[0].startTime);
    let rawDate = new Date(localDate.toLocaleString("en-US", {timeZone: givenTimezone}));

    let displayDate = "";

    //Add on the necessary date and time information by calling Date get functions.
    displayDate += (rawDate.getMonth() + 1).toString() + "/";
    displayDate += rawDate.getDate().toString() + "/";
    displayDate += rawDate.getFullYear().toString();

    displayDate += " ";

    let timeM = " ";

    if (rawDate.getHours().toString() == 0)
    {
        displayDate += "12:";
        timeM = "AM";
    }
    else if (rawDate.getHours().toString() <= 11)
    {
        displayDate += rawDate.getHours().toString() + ":";
        timeM = "AM";
    }
    else if (rawDate.getHours().toString() == 12)
    {
        displayDate += "12:";
        timeM = "PM";
    }
    else
    {
        displayDate += (rawDate.getHours() -12).toString() + ":";
        timeM = "PM";
    }

    if (rawDate.getMinutes() <= 9)
        displayDate += "0";
    
    displayDate += rawDate.getMinutes() + timeM;
    

    //Place all information onto the labels correctly.
    document.getElementById(labid).innerHTML = displayDate;
    document.getElementById(ppid).innerHTML = "Precipitation Probability: "+ weatherData.data.timelines[0].intervals[0].values.precipitationProbability + "%";
    document.getElementById(piid).innerHTML = "Precipitation Intensity: " + weatherData.data.timelines[0].intervals[0].values.precipitationIntensity + " in/h";
    
    //Using the documentation for Tomorrow.IO, convert the number codes into text for the precipiation type.
    let type =  weatherData.data.timelines[0].intervals[0].values.precipitationType;
    var wordType = "";

        if (type == 0)
            wordType = "N/A";
        else if (type == 1)
            wordType = "Rain"
        else if (type == 2)
            wordType = "Snow"
        else if (type == 3)
            wordType = "Freezing Rain"
        else
            wordType = "Ice Pellets"
        
    document.getElementById(ptid).innerHTML = "Precipitation Type: " + wordType;
    document.getElementById(wsid).innerHTML = "Wind Speed: " + weatherData.data.timelines[0].intervals[0].values.windSpeed + " mph";
    document.getElementById(wdid).innerHTML = "Wind Direction: " + weatherData.data.timelines[0].intervals[0].values.windDirection + " degrees";
    document.getElementById(tid).innerHTML = "Temperature: " + weatherData.data.timelines[0].intervals[0].values.temperature + " F";

    for (let i = 2; i <= 24; ++i)
    {
        //Repeat the above process for all forms regarding the 24-hour forecast.
        let labid = "label"+(i+1).toString();
        let ppid = "PP"+(i+1).toString()
        let piid = "PI"+(i+1).toString();
        let ptid = "PT"+(i+1).toString();
        let wsid = "WS"+(i+1).toString();
        let wgid = "WG"+(i+1).toString();
        let wdid = "WD"+(i+1).toString();
        let tid = "T"+(i+1).toString();
        let taid = "TA"+(i+1).toString();

        localDate = new Date(weatherData.data.timelines[1].intervals[i-1].startTime)
        rawDate = new Date(localDate.toLocaleString("en-US", {timeZone: givenTimezone}));

        //Only display the time, not the month.
        displayDate;
        if (rawDate.getHours().toString() == 0)
            displayDate = "12:00AM";
        else if (rawDate.getHours().toString() <= 11)
            displayDate = rawDate.getHours().toString() + ":00AM";
        else if (rawDate.getHours().toString() == 12)
            displayDate = "12:00PM";
        else
            displayDate = (rawDate.getHours() -12).toString() + ":00PM";

        // Get Time in 12-Hour System
        document.getElementById(labid).innerHTML = displayDate;
        document.getElementById(ppid).innerHTML = "Precipitation Probability: "+ weatherData.data.timelines[1].intervals[i-1].values.precipitationProbability + "%";
        document.getElementById(piid).innerHTML = "Precipitation Intensity: " + weatherData.data.timelines[1].intervals[i-1].values.precipitationIntensity + " in/h";
        
        let type =  weatherData.data.timelines[1].intervals[i-1].values.precipitationType;
        var wordType = "";

        if (type == 0)
            wordType = "N/A";
        else if (type == 1)
            wordType = "Rain"
        else if (type == 2)
            wordType = "Snow"
        else if (type == 3)
            wordType = "Freezing Rain"
        else
            wordType = "Ice Pellets"
        
        document.getElementById(ptid).innerHTML = "Precipitation Type: " + wordType;
        document.getElementById(wsid).innerHTML = "Wind Speed: " + weatherData.data.timelines[1].intervals[i-1].values.windSpeed + " mph";
        document.getElementById(wdid).innerHTML = "Wind Direction: " + weatherData.data.timelines[1].intervals[i-1].values.windDirection + " degrees";
        document.getElementById(tid).innerHTML = "Temperature: " + weatherData.data.timelines[1].intervals[i-1].values.temperature + " F";
    }

    for (let i = 2; i <= 7; ++i)
    {
        //Repeat a final time for all labels related to the 7-day forecast.
        let labid = "label"+(i+25).toString();
        let ppid = "PP"+(i+25).toString()
        let piid = "PI"+(i+25).toString();
        let ptid = "PT"+(i+25).toString();
        let wsid = "WS"+(i+25).toString();
        let wgid = "WG"+(i+25).toString();
        let wdid = "WD"+(i+25).toString();
        let tid = "T"+(i+25).toString();
        let taid = "TA"+(i+25).toString();

        //Only display the date, not the time.

        localDate = new Date(weatherData.data.timelines[2].intervals[i-1].startTime);
        rawDate = new Date(localDate.toLocaleString("en-US", {timeZone: givenTimezone}));
        displayDate = "";

        displayDate += (rawDate.getMonth() + 1).toString() + "/";
        displayDate += rawDate.getDate().toString() + "/";
        displayDate += rawDate.getFullYear().toString();

        document.getElementById(labid).innerHTML = displayDate;
        document.getElementById(ppid).innerHTML = "Precipitation Probability: "+ weatherData.data.timelines[2].intervals[i-1].values.precipitationProbability+ "%";
        document.getElementById(piid).innerHTML = "Precipitation Intensity: " + weatherData.data.timelines[2].intervals[i-1].values.precipitationIntensity + " in/h";
        
        let type =  weatherData.data.timelines[2].intervals[i-1].values.precipitationType;
        var wordType = "";

        if (type == 0)
            wordType = "N/A";
        else if (type == 1)
            wordType = "Rain"
        else if (type == 2)
            wordType = "Snow"
        else if (type == 3)
            wordType = "Freezing Rain"
        else
            wordType = "Ice Pellets"
        
        document.getElementById(ptid).innerHTML = "Precipitation Type: " + wordType;
        document.getElementById(wsid).innerHTML = "Wind Speed: " + weatherData.data.timelines[2].intervals[i-1].values.windSpeed + " mph";
        document.getElementById(wdid).innerHTML = "Wind Direction: " + weatherData.data.timelines[2].intervals[i-1].values.windDirection + " degrees";
        document.getElementById(tid).innerHTML = "Temperature: " + weatherData.data.timelines[2].intervals[i-1].values.temperature + " F";
    }

    var days = document.getElementsByClassName("dailyForm");
    var hours = document.getElementsByClassName("hourlyForm");

    

    //This ensures that the data is in 7-day forecast mode on default by changing the styles.
    Array.from(hours).forEach(hour => {
        hour.style.display="none";
    })

    Array.from(days).forEach(day => {
        day.style.display="inline-block";
    })

    document.getElementById("checker").checked = false;
}

//This function gathers the necessary information to call Tomorrow.IO and makes the call with node-fetch.
//This function is heavily based off the following tutorial on Tomorrow.IO's website:
//https://docs.tomorrow.io/reference/get-timelines -Under the tab titled: Build Your Own Weather App With One Call
function weatherCall(location)
{
    //Call the moment.utc() function to get the valid time frames for the forecast.
    const now = moment.utc();
    const startTime = moment.utc(now).add(0, "minutes").toISOString();
    const endTime = moment.utc(now).add(8, "days").toISOString(); 

    //The timezone of the city entered by the user.
    var timezone;
    var timezoneKey;

    //Get the current timestamp in seconds.
    var timestamp = (Date.now())/1000;

    //Use node-fetch to retrieve the key for the Google APIs
    fetch("../key.json")
    .then(response => response.json())
    .then(json => keys = json)
    .then(keys => {
        timezoneKey = keys.googleMapsKey
        let timezoneURL =  "https://maps.googleapis.com/maps/api/timezone/json?location=" + location +"&timestamp="+timestamp+"&key=" + timezoneKey;

        //Call the Google Timezone API to retrieve the timezone for the given city.
        fetch(timezoneURL)
        .then(response => response.json())
        .then(json => {
            timezone = json.timeZoneId;
            console.log(timezone)})
    })
    
    // Gather all the information necessary to send to Tomorrow.IO and turn it into a string.
    const getTimelineParameters =  queryString.stringify({
    apikey,
    location,
    fields,
    units,
    timesteps,
    startTime,
    endTime,
    timezone,
    }, {arrayFormat: "comma"});
                    
    var weatherData;

    // Use node-fetch to communicate with Tomorrow.IO, storing the results into weatherData and then calling
    // displayWeatherData() to display the information on the webpage.
    fetch(getTimelineURL + "?" + getTimelineParameters, {method: "GET"})
    .then((result) => result.json())
    .then(data => weatherData = data)
    .then(weatherData => displayWeatherData(weatherData, timezone))
    .catch((error) => console.error("error: " + error));

}

//This function uses the Google Maps JavaScript API to convert the user's input into longitude and latitude.
function retrieveLocation(address)
{
    //Create a Geocoder object and call the geocode function with the given address.
    //If the status is okay, send the longitude and latitude to weatherCall() to use it in Tomorrow.IO.
    var geocoder = new google.maps.Geocoder();
    geocoder.geocode({'address': address}, function(results, status) {
        if (status == 'OK') {
            var myResult = results[0].geometry.location; // reference LatLng value
            let location = [myResult.lat(), myResult.lng()];
            weatherCall(location);
        }
        else {
        alert('Map location not found.  Please adjust address.  Error: '+ status);
        }
    });
}

//This function takes the users' input and ensures the format is correct before sending it to the
//Google Maps JavaScript API.
function acceptInput()
{
    //Create two FormData objects to gather the city and state names from the user.
    var city = new FormData();
    city.append("city", document.getElementById("cityName").value);
    
    var state = new FormData();
    state.append("state", document.getElementById("stateName").value);
    
    //Ensure first that neither the city or state names are empty (or only whitespace).
    //If it is valid, then send the correct address to retrieveLocation().
    if(city.get("city").trim() != "" && state.get("state").trim() != "")
    {
        let address = city.get("city").trim() + ", " + state.get("state").trim();
        retrieveLocation(address);
    }
    else
        alert("Invalid Input!");
}

//This function loads the Google Maps JavaScript API into the index.html file by retrieve the key from key.json
//and creating a script element at the end of the html.
function loadMapsAPI()
{
    var mapsKey;

    //Use node-fetch to get the key for the Google Maps API.
    fetch("../key.json")
    .then(response => response.json())
    .then(json => keys = json)
    .then(keys => {
        mapsKey = keys.googleMapsKey
        let mapsURL =  "https://maps.googleapis.com/maps/api/js?key=" + mapsKey;

        //Create the new script element, add in the URL and then append it to body of the document.
        let mapsScript = document.createElement("script");
        mapsScript.setAttribute("src", mapsURL);
    
        document.body.appendChild(mapsScript);
    
        mapsScript.addEventListener("load", () => {console.log("File loaded");})
    })
}

//Load in the Maps API at the start of execution.
loadMapsAPI();

//Call the acceptInput() function whenever the user clicks the submit button on the form.
let form = document.getElementById("weatherInfo");
let switchData = document.getElementById("checker");

form.addEventListener("submit", function(event){
        acceptInput();
});

//Whenever the user changes the switch, call this function so that the data being displayed will change.
switchData.addEventListener("change", function(){
    var days = document.getElementsByClassName("dailyForm");
    var hours = document.getElementsByClassName("hourlyForm");
    console.log(days.length);
    
    //If the checkbox is checked, then switch to 24-hour Forecast.
    if (this.checked)
    {
        document.getElementById("dataType").textContent = "24-Hour Forecast";

        Array.from(days).forEach(day =>{
            day.style.display="none";
        })

        Array.from(hours).forEach(hour => {
            hour.style.display="inline-block";
        })
    }
    //If checkbox is not checked, then switch to 7-Day Forecast
    else
    {
        document.getElementById("dataType").textContent = "7-Day Forecast";

        Array.from(hours).forEach(hour => {
            hour.style.display="none";
        })

        Array.from(days).forEach(day => {
            day.style.display="inline-block";
        })
    }
});